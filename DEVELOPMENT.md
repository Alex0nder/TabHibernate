# План развития Tab Hibernate

Цель: стабильная, предсказуемая работа без сбоев при долгой работе и после сна Service Worker.

---

## 1. Стабильность (приоритет высокий)

| Задача | Зачем |
|--------|--------|
| **Восстанавливать state при каждом срабатывании alarm** | После сна SW память пуста; без восстановления `lastActivityByTab` из storage все вкладки считаются неактивными и могут массово суспендиться. |
| **Throttle записи lastActivity в storage** | Частые `persistLastActivity()` при каждом движении мыши создают лишнюю нагрузку и могут упираться в лимиты storage. Ограничить до 1 раза в 3–5 сек. |
| **Обработка ошибок в onMessage** | Все async-ответы оборачивать в try/catch и всегда вызывать `sendResponse`, иначе popup/suspended зависнут в ожидании. |
| **Новые вкладки помечать как активные** | Подписка на `chrome.tabs.onCreated` — иначе новая вкладка без content script до первого переключения может сразу считаться неактивной. |
| **Suspended page без зависимости от SW** | Читать данные восстановления из `chrome.storage.local` прямо в suspended.js — страница будет работать, даже если SW спит. |
| **Периодическая очистка lastActivityByTab** | Удалять из map/storage записи по несуществующим tabId (после закрытия вкладок), чтобы не раздувать storage при долгой работе. |

---

## 2. Надёжность API и граничные случаи

| Задача | Зачем |
|--------|--------|
| **Проверять существование таба перед discard/update** | `chrome.tabs.get(tabId)` перед действием — избежать ошибок «tab not found» при быстром закрытии. |
| **Квоты storage** | Не хранить бесконечную историю бэкапов; ограничить число дней или размер ключей `backup_YYYY-MM-DD` (например, хранить последние 30 дней). |
| **Закладки: лимит на создание** | При сотнях вкладок создавать закладки батчами или с задержкой, обрабатывать отказы и не падать. |
| **Alarm при отключении расширения** | При `enabled: false` не удалять alarm (чтобы не терять его при повторном включении), а просто не выполнять suspend в `onAlarmCheck`. Уже так сделано. |

---

## 3. UX и обратная связь

| Задача | Зачем |
|--------|--------|
| **Popup: проверка доступности SW** | Если popup открыт после долгого простоя, первый `sendMessage` может не дойти. Повтор запроса 1–2 раза с небольшой задержкой или показать «Обновить». |
| **Popup: явная обработка lastError** | Проверять `chrome.runtime.lastError` во всех колбэках sendMessage и показывать пользователю короткое сообщение при ошибке. |
| **Бейдж на иконке** | Показывать число приостановленных сегодня вкладок (опционально). |
| **Уведомление при первом суспенде** | Один раз показать, что расширение сработало (опционально, с настройкой «не показывать снова»). |

---

## 4. Дальнейшие функции (по желанию)

| Задача | Зачем |
|--------|--------|
| **Белый список сайтов** | Не суспендить выбранные домены (например, почта, мессенджеры). |
| **Исключение вкладок с несохранёнными формами** | Нереализуемо надёжно без внедрения в страницу; только документировать ограничение. |
| **Режим «суспендить в инкогнито»** | Опция в настройках. |
| **Экспорт/импорт настроек** | Резервная копия настроек в JSON. |
| **Минимальный интервал проверки** | Сейчас 1 мин; при желании сделать настраиваемым (1/2/5 мин) с оговоркой про нагрузку на батарею. |

---

## 5. Качество кода и поддержка

| Задача | Зачем |
|--------|--------|
| **Единый префикс логов** | Все сообщения с `[TabHibernate]` для фильтрации в chrome://extensions → Service worker → Inspect. |
| **Версионирование storage** | Ключ `storageVersion` в storage; при обновлении расширения при необходимости мигрировать старые ключи. |
| **Комментарии к неочевидному поведению Chrome** | Например: alarm может сработать с задержкой после пробуждения SW; content script не инжектируется в chrome:// и т.д. |

---

## Реализовано в коде (текущий коммит)

- Восстановление `lastActivityByTab` в начале `onAlarmCheck`.
- Throttle `persistLastActivity` (не чаще раза в 4 сек).
- Все async-обработчики сообщений с try/catch и гарантированным `sendResponse`.
- `tabs.onCreated` — новые вкладки помечаются как активные.
- Suspended page читает данные из `chrome.storage.local` напрямую (не зависит от SW).
- Очистка записей по несуществующим вкладкам при проверке по alarm.
